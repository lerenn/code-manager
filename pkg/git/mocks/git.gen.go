// Code generated by MockGen. DO NOT EDIT.
// Source: git.go
//
// Generated by this command:
//
//	mockgen -source=git.go -destination=mocks/git.gen.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	git "github.com/lerenn/code-manager/pkg/git"
	gomock "go.uber.org/mock/gomock"
)

// MockGit is a mock of Git interface.
type MockGit struct {
	ctrl     *gomock.Controller
	recorder *MockGitMockRecorder
	isgomock struct{}
}

// MockGitMockRecorder is the mock recorder for MockGit.
type MockGitMockRecorder struct {
	mock *MockGit
}

// NewMockGit creates a new mock instance.
func NewMockGit(ctrl *gomock.Controller) *MockGit {
	mock := &MockGit{ctrl: ctrl}
	mock.recorder = &MockGitMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGit) EXPECT() *MockGitMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockGit) Add(repoPath string, files ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{repoPath}
	for _, a := range files {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Add", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add.
func (mr *MockGitMockRecorder) Add(repoPath any, files ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{repoPath}, files...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockGit)(nil).Add), varargs...)
}

// AddRemote mocks base method.
func (m *MockGit) AddRemote(repoPath, remoteName, remoteURL string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddRemote", repoPath, remoteName, remoteURL)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddRemote indicates an expected call of AddRemote.
func (mr *MockGitMockRecorder) AddRemote(repoPath, remoteName, remoteURL any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRemote", reflect.TypeOf((*MockGit)(nil).AddRemote), repoPath, remoteName, remoteURL)
}

// BranchExists mocks base method.
func (m *MockGit) BranchExists(repoPath, branch string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BranchExists", repoPath, branch)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BranchExists indicates an expected call of BranchExists.
func (mr *MockGitMockRecorder) BranchExists(repoPath, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BranchExists", reflect.TypeOf((*MockGit)(nil).BranchExists), repoPath, branch)
}

// BranchExistsOnRemote mocks base method.
func (m *MockGit) BranchExistsOnRemote(params git.BranchExistsOnRemoteParams) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BranchExistsOnRemote", params)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BranchExistsOnRemote indicates an expected call of BranchExistsOnRemote.
func (mr *MockGitMockRecorder) BranchExistsOnRemote(params any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BranchExistsOnRemote", reflect.TypeOf((*MockGit)(nil).BranchExistsOnRemote), params)
}

// CheckReferenceConflict mocks base method.
func (m *MockGit) CheckReferenceConflict(repoPath, branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckReferenceConflict", repoPath, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckReferenceConflict indicates an expected call of CheckReferenceConflict.
func (mr *MockGitMockRecorder) CheckReferenceConflict(repoPath, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckReferenceConflict", reflect.TypeOf((*MockGit)(nil).CheckReferenceConflict), repoPath, branch)
}

// CheckoutBranch mocks base method.
func (m *MockGit) CheckoutBranch(worktreePath, branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckoutBranch", worktreePath, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckoutBranch indicates an expected call of CheckoutBranch.
func (mr *MockGitMockRecorder) CheckoutBranch(worktreePath, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckoutBranch", reflect.TypeOf((*MockGit)(nil).CheckoutBranch), worktreePath, branch)
}

// Clone mocks base method.
func (m *MockGit) Clone(params git.CloneParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Clone", params)
	ret0, _ := ret[0].(error)
	return ret0
}

// Clone indicates an expected call of Clone.
func (mr *MockGitMockRecorder) Clone(params any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clone", reflect.TypeOf((*MockGit)(nil).Clone), params)
}

// CloneToPath mocks base method.
func (m *MockGit) CloneToPath(sourceRepoPath, targetPath, branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloneToPath", sourceRepoPath, targetPath, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// CloneToPath indicates an expected call of CloneToPath.
func (mr *MockGitMockRecorder) CloneToPath(sourceRepoPath, targetPath, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloneToPath", reflect.TypeOf((*MockGit)(nil).CloneToPath), sourceRepoPath, targetPath, branch)
}

// Commit mocks base method.
func (m *MockGit) Commit(repoPath, message string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", repoPath, message)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockGitMockRecorder) Commit(repoPath, message any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockGit)(nil).Commit), repoPath, message)
}

// ConfigGet mocks base method.
func (m *MockGit) ConfigGet(workDir, key string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConfigGet", workDir, key)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConfigGet indicates an expected call of ConfigGet.
func (mr *MockGitMockRecorder) ConfigGet(workDir, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConfigGet", reflect.TypeOf((*MockGit)(nil).ConfigGet), workDir, key)
}

// CreateBranch mocks base method.
func (m *MockGit) CreateBranch(repoPath, branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBranch", repoPath, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateBranch indicates an expected call of CreateBranch.
func (mr *MockGitMockRecorder) CreateBranch(repoPath, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBranch", reflect.TypeOf((*MockGit)(nil).CreateBranch), repoPath, branch)
}

// CreateBranchFrom mocks base method.
func (m *MockGit) CreateBranchFrom(params git.CreateBranchFromParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBranchFrom", params)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateBranchFrom indicates an expected call of CreateBranchFrom.
func (mr *MockGitMockRecorder) CreateBranchFrom(params any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBranchFrom", reflect.TypeOf((*MockGit)(nil).CreateBranchFrom), params)
}

// CreateWorktree mocks base method.
func (m *MockGit) CreateWorktree(repoPath, worktreePath, branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateWorktree", repoPath, worktreePath, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateWorktree indicates an expected call of CreateWorktree.
func (mr *MockGitMockRecorder) CreateWorktree(repoPath, worktreePath, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorktree", reflect.TypeOf((*MockGit)(nil).CreateWorktree), repoPath, worktreePath, branch)
}

// CreateWorktreeWithNoCheckout mocks base method.
func (m *MockGit) CreateWorktreeWithNoCheckout(repoPath, worktreePath, branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateWorktreeWithNoCheckout", repoPath, worktreePath, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateWorktreeWithNoCheckout indicates an expected call of CreateWorktreeWithNoCheckout.
func (mr *MockGitMockRecorder) CreateWorktreeWithNoCheckout(repoPath, worktreePath, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorktreeWithNoCheckout", reflect.TypeOf((*MockGit)(nil).CreateWorktreeWithNoCheckout), repoPath, worktreePath, branch)
}

// FetchRemote mocks base method.
func (m *MockGit) FetchRemote(repoPath, remoteName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchRemote", repoPath, remoteName)
	ret0, _ := ret[0].(error)
	return ret0
}

// FetchRemote indicates an expected call of FetchRemote.
func (mr *MockGitMockRecorder) FetchRemote(repoPath, remoteName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchRemote", reflect.TypeOf((*MockGit)(nil).FetchRemote), repoPath, remoteName)
}

// GetBranchRemote mocks base method.
func (m *MockGit) GetBranchRemote(repoPath, branch string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBranchRemote", repoPath, branch)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBranchRemote indicates an expected call of GetBranchRemote.
func (mr *MockGitMockRecorder) GetBranchRemote(repoPath, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBranchRemote", reflect.TypeOf((*MockGit)(nil).GetBranchRemote), repoPath, branch)
}

// GetCurrentBranch mocks base method.
func (m *MockGit) GetCurrentBranch(repoPath string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCurrentBranch", repoPath)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCurrentBranch indicates an expected call of GetCurrentBranch.
func (mr *MockGitMockRecorder) GetCurrentBranch(repoPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCurrentBranch", reflect.TypeOf((*MockGit)(nil).GetCurrentBranch), repoPath)
}

// GetDefaultBranch mocks base method.
func (m *MockGit) GetDefaultBranch(remoteURL string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDefaultBranch", remoteURL)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDefaultBranch indicates an expected call of GetDefaultBranch.
func (mr *MockGitMockRecorder) GetDefaultBranch(remoteURL any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDefaultBranch", reflect.TypeOf((*MockGit)(nil).GetDefaultBranch), remoteURL)
}

// GetRemoteURL mocks base method.
func (m *MockGit) GetRemoteURL(repoPath, remoteName string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRemoteURL", repoPath, remoteName)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRemoteURL indicates an expected call of GetRemoteURL.
func (mr *MockGitMockRecorder) GetRemoteURL(repoPath, remoteName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRemoteURL", reflect.TypeOf((*MockGit)(nil).GetRemoteURL), repoPath, remoteName)
}

// GetRepositoryName mocks base method.
func (m *MockGit) GetRepositoryName(repoPath string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRepositoryName", repoPath)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRepositoryName indicates an expected call of GetRepositoryName.
func (mr *MockGitMockRecorder) GetRepositoryName(repoPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRepositoryName", reflect.TypeOf((*MockGit)(nil).GetRepositoryName), repoPath)
}

// GetWorktreePath mocks base method.
func (m *MockGit) GetWorktreePath(repoPath, branch string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorktreePath", repoPath, branch)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorktreePath indicates an expected call of GetWorktreePath.
func (mr *MockGitMockRecorder) GetWorktreePath(repoPath, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorktreePath", reflect.TypeOf((*MockGit)(nil).GetWorktreePath), repoPath, branch)
}

// IsClean mocks base method.
func (m *MockGit) IsClean(repoPath string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClean", repoPath)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsClean indicates an expected call of IsClean.
func (mr *MockGitMockRecorder) IsClean(repoPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClean", reflect.TypeOf((*MockGit)(nil).IsClean), repoPath)
}

// RemoteExists mocks base method.
func (m *MockGit) RemoteExists(repoPath, remoteName string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoteExists", repoPath, remoteName)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemoteExists indicates an expected call of RemoteExists.
func (mr *MockGitMockRecorder) RemoteExists(repoPath, remoteName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoteExists", reflect.TypeOf((*MockGit)(nil).RemoteExists), repoPath, remoteName)
}

// RemoveWorktree mocks base method.
func (m *MockGit) RemoveWorktree(repoPath, worktreePath string, force bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveWorktree", repoPath, worktreePath, force)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWorktree indicates an expected call of RemoveWorktree.
func (mr *MockGitMockRecorder) RemoveWorktree(repoPath, worktreePath, force any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWorktree", reflect.TypeOf((*MockGit)(nil).RemoveWorktree), repoPath, worktreePath, force)
}

// SetUpstreamBranch mocks base method.
func (m *MockGit) SetUpstreamBranch(repoPath, remote, branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUpstreamBranch", repoPath, remote, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetUpstreamBranch indicates an expected call of SetUpstreamBranch.
func (mr *MockGitMockRecorder) SetUpstreamBranch(repoPath, remote, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUpstreamBranch", reflect.TypeOf((*MockGit)(nil).SetUpstreamBranch), repoPath, remote, branch)
}

// Status mocks base method.
func (m *MockGit) Status(workDir string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status", workDir)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Status indicates an expected call of Status.
func (mr *MockGitMockRecorder) Status(workDir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockGit)(nil).Status), workDir)
}

// WorktreeExists mocks base method.
func (m *MockGit) WorktreeExists(repoPath, branch string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WorktreeExists", repoPath, branch)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WorktreeExists indicates an expected call of WorktreeExists.
func (mr *MockGitMockRecorder) WorktreeExists(repoPath, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WorktreeExists", reflect.TypeOf((*MockGit)(nil).WorktreeExists), repoPath, branch)
}
