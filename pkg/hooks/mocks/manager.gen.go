// Code generated by MockGen. DO NOT EDIT.
// Source: manager.go
//
// Generated by this command:
//
//	mockgen -source=manager.go -destination=mocks/manager.gen.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	hooks "github.com/lerenn/code-manager/pkg/hooks"
	gomock "go.uber.org/mock/gomock"
)

// MockHookManagerInterface is a mock of HookManagerInterface interface.
type MockHookManagerInterface struct {
	ctrl     *gomock.Controller
	recorder *MockHookManagerInterfaceMockRecorder
	isgomock struct{}
}

// MockHookManagerInterfaceMockRecorder is the mock recorder for MockHookManagerInterface.
type MockHookManagerInterfaceMockRecorder struct {
	mock *MockHookManagerInterface
}

// NewMockHookManagerInterface creates a new mock instance.
func NewMockHookManagerInterface(ctrl *gomock.Controller) *MockHookManagerInterface {
	mock := &MockHookManagerInterface{ctrl: ctrl}
	mock.recorder = &MockHookManagerInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHookManagerInterface) EXPECT() *MockHookManagerInterfaceMockRecorder {
	return m.recorder
}

// DisableHook mocks base method.
func (m *MockHookManagerInterface) DisableHook(operation, hookName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DisableHook", operation, hookName)
	ret0, _ := ret[0].(error)
	return ret0
}

// DisableHook indicates an expected call of DisableHook.
func (mr *MockHookManagerInterfaceMockRecorder) DisableHook(operation, hookName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DisableHook", reflect.TypeOf((*MockHookManagerInterface)(nil).DisableHook), operation, hookName)
}

// EnableHook mocks base method.
func (m *MockHookManagerInterface) EnableHook(operation, hookName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnableHook", operation, hookName)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnableHook indicates an expected call of EnableHook.
func (mr *MockHookManagerInterfaceMockRecorder) EnableHook(operation, hookName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableHook", reflect.TypeOf((*MockHookManagerInterface)(nil).EnableHook), operation, hookName)
}

// ExecuteErrorHooks mocks base method.
func (m *MockHookManagerInterface) ExecuteErrorHooks(operation string, ctx *hooks.HookContext) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteErrorHooks", operation, ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteErrorHooks indicates an expected call of ExecuteErrorHooks.
func (mr *MockHookManagerInterfaceMockRecorder) ExecuteErrorHooks(operation, ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteErrorHooks", reflect.TypeOf((*MockHookManagerInterface)(nil).ExecuteErrorHooks), operation, ctx)
}

// ExecutePostHooks mocks base method.
func (m *MockHookManagerInterface) ExecutePostHooks(operation string, ctx *hooks.HookContext) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecutePostHooks", operation, ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecutePostHooks indicates an expected call of ExecutePostHooks.
func (mr *MockHookManagerInterfaceMockRecorder) ExecutePostHooks(operation, ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecutePostHooks", reflect.TypeOf((*MockHookManagerInterface)(nil).ExecutePostHooks), operation, ctx)
}

// ExecutePreHooks mocks base method.
func (m *MockHookManagerInterface) ExecutePreHooks(operation string, ctx *hooks.HookContext) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecutePreHooks", operation, ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecutePreHooks indicates an expected call of ExecutePreHooks.
func (mr *MockHookManagerInterfaceMockRecorder) ExecutePreHooks(operation, ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecutePreHooks", reflect.TypeOf((*MockHookManagerInterface)(nil).ExecutePreHooks), operation, ctx)
}

// ExecuteWorktreeCheckoutHooks mocks base method.
func (m *MockHookManagerInterface) ExecuteWorktreeCheckoutHooks(operation string, ctx *hooks.HookContext) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteWorktreeCheckoutHooks", operation, ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteWorktreeCheckoutHooks indicates an expected call of ExecuteWorktreeCheckoutHooks.
func (mr *MockHookManagerInterfaceMockRecorder) ExecuteWorktreeCheckoutHooks(operation, ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteWorktreeCheckoutHooks", reflect.TypeOf((*MockHookManagerInterface)(nil).ExecuteWorktreeCheckoutHooks), operation, ctx)
}

// ListHooks mocks base method.
func (m *MockHookManagerInterface) ListHooks(operation string) ([]hooks.Hook, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListHooks", operation)
	ret0, _ := ret[0].([]hooks.Hook)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListHooks indicates an expected call of ListHooks.
func (mr *MockHookManagerInterfaceMockRecorder) ListHooks(operation any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListHooks", reflect.TypeOf((*MockHookManagerInterface)(nil).ListHooks), operation)
}

// RegisterErrorHook mocks base method.
func (m *MockHookManagerInterface) RegisterErrorHook(operation string, hook hooks.ErrorHook) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterErrorHook", operation, hook)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterErrorHook indicates an expected call of RegisterErrorHook.
func (mr *MockHookManagerInterfaceMockRecorder) RegisterErrorHook(operation, hook any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterErrorHook", reflect.TypeOf((*MockHookManagerInterface)(nil).RegisterErrorHook), operation, hook)
}

// RegisterPostHook mocks base method.
func (m *MockHookManagerInterface) RegisterPostHook(operation string, hook hooks.PostHook) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterPostHook", operation, hook)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterPostHook indicates an expected call of RegisterPostHook.
func (mr *MockHookManagerInterfaceMockRecorder) RegisterPostHook(operation, hook any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterPostHook", reflect.TypeOf((*MockHookManagerInterface)(nil).RegisterPostHook), operation, hook)
}

// RegisterPreHook mocks base method.
func (m *MockHookManagerInterface) RegisterPreHook(operation string, hook hooks.PreHook) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterPreHook", operation, hook)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterPreHook indicates an expected call of RegisterPreHook.
func (mr *MockHookManagerInterfaceMockRecorder) RegisterPreHook(operation, hook any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterPreHook", reflect.TypeOf((*MockHookManagerInterface)(nil).RegisterPreHook), operation, hook)
}

// RegisterWorktreeCheckoutHook mocks base method.
func (m *MockHookManagerInterface) RegisterWorktreeCheckoutHook(operation string, hook hooks.WorktreeCheckoutHook) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterWorktreeCheckoutHook", operation, hook)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterWorktreeCheckoutHook indicates an expected call of RegisterWorktreeCheckoutHook.
func (mr *MockHookManagerInterfaceMockRecorder) RegisterWorktreeCheckoutHook(operation, hook any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterWorktreeCheckoutHook", reflect.TypeOf((*MockHookManagerInterface)(nil).RegisterWorktreeCheckoutHook), operation, hook)
}

// RemoveHook mocks base method.
func (m *MockHookManagerInterface) RemoveHook(operation, hookName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveHook", operation, hookName)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveHook indicates an expected call of RemoveHook.
func (mr *MockHookManagerInterfaceMockRecorder) RemoveHook(operation, hookName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveHook", reflect.TypeOf((*MockHookManagerInterface)(nil).RemoveHook), operation, hookName)
}
