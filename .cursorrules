# CM Project Rules

## Testing
- **Adapters** (`pkg/fs`): integration tests only, real file system
- **Business Logic** (`pkg/cm`): unit tests only, mocked dependencies  
- **E2E Tests** (`test/`): real CM struct + Git operations
- **Build tags**: `//go:build unit|integration|e2e`
- **File naming**: `*_test.go` (standard), `*_integration_test.go` (integration), `*_test.go` in `test/` (e2e)
- **Mocking**: Uber gomock, `//go:generate go run go.uber.org/mock/mockgen@v0.5.2`, commit `*_gen.go`
- **Assertions**: `testify/assert`, `assert.ErrorIs()` for specific errors (not `assert.Contains()`)
- **System protection**: NEVER touch `~/.cm/` files, ALWAYS use `os.MkdirTemp()`, use `-c` flag for CLI testing
- **Mocking strategy**: Mock immediate dependencies only, not transitive ones

## Function Design
- **Option structs**: `XXXOpts` for optional params, variadic `...XXXOpts`, check `len(opts) > 0`
- **Parameter structs**: `XXXParams` for >3 args (excl. context/opts), single struct param
- **NO proxy functions**: Direct parameter struct acceptance, no wrapper functions

## CLI Architecture  
- **CLI**: boilerplate only (flags, config, basic validation, CM calls, display)
- **NO business logic in CLI**: All parsing/validation in CM package
- **Thin CLI**: Pass args to CM methods, display results

## Shipping Process
**ONLY when user says "ship"**: 
1. `go generate ./...`
2. `dagger call lint --source-dir=.` (fix errors)
3. `dagger call unit-tests --source-dir .` (fix errors, STOP if fail)
4. `dagger call integration-tests --source-dir .` (fix errors, STOP if fail)  
5. `dagger call end-to-end-tests --source-dir .` (fix errors, STOP if fail)
6. Create branch (if on main): `feat/description` or `fix/description` format.
   If not on main, read the actual branch name to determine the prefix (feat, fix, ci, chore, etc).
7. Commit: conventional format title + full chat summary
8. Push branch

**ALL tests MUST pass before shipping**
